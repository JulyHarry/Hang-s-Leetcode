# 状态动态规划
## 数据范围
n <= 20
## 适用场景
枚举所有情况，暴力求解，找到状态转移方程
## 例题
### 1986. 完成任务的最少工作时间段
https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/
#### 题目分析
* 枚举每一种可能性，可以使用二进制形式，进行表示每一种可能；用 `mask` 表示当前的二进制;
* 二进制形式中的 `1` 表示工作已执行， `0` 表示工作未执行;
* 以 `nums = [1, 5, 1, 2, 4]` 为例，若想用二进制表示，那么需要 `2^nums.length` 个数才能全部表示;
* 二进制的低位表示数组的低序号，高位表示数组的高序号；以 `11010` 为例，表示第2个的'5'，第4个的'2'，第5个的'4'已完成;
* `mask` 一定可以由其子集 `subset` 状态转移得到，如果此时的`subset`为最后一个工作状态，那么 `dp[mask] = dp[mask\subset] + 1`;
* 如果遍历 `mask` 的所有子集，那么 `dp[mask] = Math.min(dp[mask], dp[mask\subset] + 1)`;
* 其中 `mask\subset` 表示将 `subset` 中的所有 `1` 从 `mask` 中移除后的二进制表示，可以使用按位异或运算求出;
* 另外需要注意保证 `subset` 中每一个工作总量应该小于 `session` ，所以需要提前做预处理，遍历 `mask` ，得到当前状态是否满足条件，
当进行状态转移时判断子集是否满足条件;
* 枚举 `mask` 的子集有一个经典的小技巧，对应的伪代码如下：
    ```java
    subset = mask
    while (subset != 0 ) {
        // subset 是 mask 的一个子集，可以用其进行状态转移
        ...
        // 使用按位与运算在 O(1) 的时间快速得到下一个（即更小的）mask 的子集
        subset = (subset - 1) & mask
    }
    ```
  >现在来讲一讲为什么是这样的一个枚举方法，先让我们来举一个例子来模拟一下。
  >假设我们当前要枚举的是 `(10110)2`  的子集（子集仍然用 `S1` 表示）：  
  `S1 = (10110)2 → (10100)2 → (10010)2 → (10000)2 → (110)2 → (100)2 → (10)2`
  >根据例子，我们发现按照上面代码得到的结果是正确的，并且是把子集按照从大到小的顺序枚举出来的。  
  那么接下来我们来谈谈这样枚举的正确性。  
  首先，一个集合它自己本身也是自己的一个集合，所以我们从这个集合本身开始枚举。  
  既然是枚举，那我们就先考虑把当前枚举得到的子集先 `−1`，
  > 但是这样做不能保证 `-1` 后得到的状态是原状态的子集，但是我们注意到：**根据与运算 `&` 的性质，
  > 如果两个数 ` a` ，` b` ， 且 `a < b` ，对这两个数进行 `&` 运算得到 `a & b`，
  > 一定是 `b` 的子集**，因为与运算得到的结果 `a & b` ，
  > 在二进制中出现  `1` 的位， 在 `b` 中对应的位置上一定也是 `1`。  
  >现在已经说明了这样做确实得到了原集合的子集，但是还没有说明我们已经枚举完了原集合的子集。  
  其实枚举子集就相当于在原集合的二进制状态下把一些  `1` 换为`0` ，而我们每次 `− 1` ，然后进行与运算其实就是在把当前子集的最右边的 `1` （位为 `x` ）变为 `0`，而它的右侧 (位为 `x-1` ~ `1` ) 全部变为 `1` ，然后进行与运算把新增的 `1` 中不该出现的抹去，最后只剩下了原集合中存在的 了。
#### 复杂度分析
时间复杂度： `O(3^n)`  
由于长度为 `n` 且包含 `k` 个 `1` 的二进制表示有 `C(n, k)` 个，且有 `2^k` 个子集，符合 `3^n` 的二项式展开式
空间复杂度： `O(2^n)`
预处理的数组 `valid` 以及动态规划的数组 `dp` 需要使用的空间

#### 代码实现
```java
class Solution {
    public int minSessions(int[] tasks, int sessionTime) {
        int n = tasks.length;
        boolean[] valid = new boolean[1 << n];
        int[] dp = new int[1 << n];
        Arrays.fill(dp, 20);
        dp[0] = 0;
        for (int mask = 1; mask < 1 << n; mask++) {
            int cur = 0;
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) != 0) {
                    cur += tasks[i];
                }
            }
            if (cur <= sessionTime) {
                valid[mask] = true;
            }
        }
        for (int mask = 1; mask < 1 << n; mask++) {
            for (int subset = mask; subset > 0; subset = (subset - 1) & mask) {
                if (valid[subset]) {
                    dp[mask] = Math.min(dp[mask], dp[mask ^ subset] + 1);
                }
            }
        }
        return dp[(1 << n) - 1];
    }
}
```